# 코테 보기 전

[알아두면 좋을거 - 지식](https://velog.io/@rhdmstj17/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9C%BC%EB%A1%9C-%EC%BD%94%ED%85%8C-%ED%92%80%EC%9D%B4%ED%95%98%EA%B8%B0-%EC%A0%84-%EC%88%99%EC%A7%80%ED%95%98%EB%A9%B4-%EC%A2%8B%EC%9D%84-9%EA%B0%80%EC%A7%80)

[코드짜기](https://seongbindb.tistory.com/54)


딕셔너리로 반환되는 함수들이 있고 딕셔너리 자체로도 시험이 나오기 때문에 programers 해시 문제를 좀 풀어보기로 했다.

[프로그래머스 해시](https://school.programmers.co.kr/learn/courses/30/lessons/42579?language=python3)

# 배낭 문제
```python
import sys
input = sys.stdin.readline


N, K = map(int, input().split())

items = [] 

for _ in range(N):
    w, v = map(int,input().split())
    items.append((w,v))
    
DP = [0] * (K+1)

for item in items:
    if item[0] > K:
        continue
    for can_weight in range(K, item[0] -1 , -1):
        DP[can_weight] = max(DP[can_weight], DP[can_weight-item[0]] + item[1])
        
print(DP[K])
```

# 해시 

해시를 사용해야만 하는 경우는 당연하겠지만 인덱스를 특수한 경우로 두어야 하는 케이스이다.

items()를 쓰면 딕셔너리의 key와 value를 쌍(튜플)으로 나옴


# 파이썬 함수들 

```python
list.sort()
return = sorted(list, )
```
둘다 key = lamda x : (-x[0],x[1]) 이렇게 사용할 수 있음


# BFS, DFS
그리디 위에 탐색이 아닌 경우 당황하지 말고 구조를 생각해라 

## BFS (Breadth-First Search, 너비 우선 탐색)
- **자료구조**: Queue (deque 사용)
- **탐색 순서**: 가까운 노드부터 차례대로
- **용도**: 최단 거리, 최소 이동 횟수

레벨 별로 가능한 케이스를 queue에 담는다. 답이 나오면 바로 return "최소거리이기 때문"

### 언제 사용?
- "최단 거리"를 구하라
- "최소 몇 번"만에 도달하는가
- 레벨별로 탐색해야 하는 경우
- 가중치가 없는 그래프의 최단 경로

### 기본 템플릿
```python
from collections import deque

def bfs(start):
    queue = deque([start])
    visited = set([start])
    
    while queue:
        now = queue.popleft()
        
        # 인접 노드 탐색
        for next in graph[now]:
            if next not in visited:
                visited.add(next)
                queue.append(next)
```


### 레벨별 탐색 (거리 측정)
```python
def bfs_with_level(start):
    queue = deque([(start, 0)])  # (노드, 거리)
    visited = set([start])
    
    while queue:
        now, dist = queue.popleft()
        
        if now == target:  # 목표 도달
            return dist
        
        for next in graph[now]:
            if next not in visited:
                visited.add(next)
                queue.append((next, dist + 1))
```

---

## DFS (Depth-First Search, 깊이 우선 탐색)
- **자료구조**: Stack (재귀 or 명시적 스택)
- **탐색 순서**: 끝까지 파고들어가서 탐색
- **용도**: 경로 찾기, 사이클 검사, 백트래킹

### 언제 사용?
- "모든 경로"를 탐색해야 하는 경우
- 백트래킹 문제 (조합, 순열)
- 사이클 존재 여부 확인
- 경로를 저장해야 하는 경우
- "가능한가?"를 물어보는 경우

### 기본 템플릿 (재귀)
```python
def dfs(node, visited):
    visited.add(node)
    
    for next in graph[node]:
        if next not in visited:
            dfs(next, visited)
```

### 백트래킹 템플릿
```python
def dfs(node, path, visited):
    # 종료 조건
    if len(path) == target_length:
        answer.append(path[:])  # 복사 필수!
        return
    
    # 탐색
    for next in graph[node]:
        if next not in visited:
            visited.add(next)
            path.append(next)
            
            dfs(next, path, visited)
            
            # 백트래킹
            visited.remove(next)
            path.pop()
```

인자로는 이렇게 현재 방문하는 노드, 그리고 트래킹하는 path를 담고 있다.


---

## 특수 패턴 : 사이클 검사 (DFS)
```python
def has_cycle(node, visited, rec_stack):
    visited.add(node)
    rec_stack.add(node)
    
    for next in graph[node]:
        if next not in visited:
            if has_cycle(next, visited, rec_stack):
                return True
        elif next in rec_stack:  # 사이클 발견!
            return True
    
    rec_stack.remove(node)
    return False
```

---

